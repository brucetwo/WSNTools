// *** WARNING ****** WARNING ****** WARNING ****** WARNING ****** WARNING ***
// ***                                                                     ***
// *** This file was automatically generated by generateRpc.pl.   ***
// *** Any and all changes made to this file WILL BE LOST!                 ***
// ***                                                                     ***
// *** WARNING ****** WARNING ****** WARNING ****** WARNING ****** WARNING ***

#ifndef TOSH_DATA_LENGTH
#define TOSH_DATA_LENGTH 28
#endif

/*#ifndef RPC_NO_DRAIN
includes Drain; 
#endif // !RPC_NO_DRAIN*/
includes RamSymbols;
includes Rpc;

module RpcM {
  provides {
    //interface StdControl;
    interface SplitControl;

    /*** events that are rpc-able ***/
  }
 uses {
    //interface StdControl as SubControl;
    interface Leds;

    //interface ReceiveMsg as CommandReceiveLocal;
    interface Receive;

    //interface SendMsg as ResponseSendMsg;
    interface AMSend;
    interface AMPacket;
    /*#ifndef RPC_NO_DRAIN
    interface Send as DrainSend; // only used for the getBuffer(), when we are using Drain
#endif // !RPC_NO_DRAIN
//    interface SendMsg as ErrorSendMsgDrain;


#ifndef RPC_NO_DRIP
    interface Receive as CommandReceiveDrip;
    interface Drip as CommandDrip;
    interface Dest;
    #endif // !RPC_NO_DRIP*/

    /*** commands that are rpc-able ***/

    command void BlinkC_initLeds (  );
    command void BlinkC_initLeds2 (   uint8_t value );
    command ramSymbol_t RamSymbolsM_peek (   unsigned int memAddress, uint8_t length, bool dereference );
    command unsigned int RamSymbolsM_poke (   ramSymbol_t* symbol );
  }
}
implementation {

  message_t dripStore;
  message_t cmdStore;
  message_t responseMsgBuf;
  message_t* responseMsgPtr;
  uint16_t dripStoreLength;
  uint16_t cmdStoreLength;
  uint16_t queryID;
  uint16_t returnAddress;
  bool processingCommand;
  bool sendingResponse;

  static const uint8_t args_sizes[4] = {
    0,
    sizeof(uint8_t),
    sizeof(unsigned int)+sizeof(uint8_t)+sizeof(bool),
    sizeof(ramSymbol_t)
  };

  static const uint8_t return_sizes[4] = {
    sizeof(void),
    sizeof(void),
    sizeof(ramSymbol_t),
    sizeof(unsigned int)
  };

  command error_t SplitControl.start() {
    responseMsgPtr = &responseMsgBuf;
    processingCommand=FALSE;
    sendingResponse=FALSE;
/*#ifndef RPC_NO_DRIP
    call CommandDrip.init();
#endif // !RPC_NO_DRIP*/
    return SUCCESS;
  }

  command error_t SplitControl.stop() {
    return SUCCESS;
  }

  /*  command error_t StdControl.init() {
    responseMsgPtr = &responseMsgBuf;
    processingCommand=FALSE;
    sendingResponse=FALSE;
    call SubControl.init();
    return SUCCESS;
    }*/

  /*  command error_t StdControl.start() {
    call SubControl.start();
#ifndef RPC_NO_DRIP
    call CommandDrip.init();
#endif // !RPC_NO_DRIP
    return SUCCESS;
  }

  command error_t StdControl.stop() {
    return SUCCESS;
    }*/

  task void processCommand(){
    RpcCommandMsg* msg = (RpcCommandMsg*)cmdStore.data;
    uint8_t* byteSrc = (uint8_t*)msg->data;
    uint16_t maxLength;
    uint16_t id = msg->commandID;
    //#ifdef RPC_NO_DRAIN    
    RpcResponseMsg *responseMsg = (RpcResponseMsg*)(responseMsgPtr->data);
    maxLength = TOSH_DATA_LENGTH;
    /*#else 
    RpcResponseMsg *responseMsg = (RpcResponseMsg*)call DrainSend.getBuffer(responseMsgPtr, &maxLength);
    //#endif // RPC_NO_DRAIN    */
    
    //dbg(DBG_USR2, "processing command id %d, transaction %d\n", msg->commandID, msg->transactionID);
    

    if ( sendingResponse == TRUE ) {
      //dbg(DBG_USR2, "stopped processing because sending\n");
      post processCommand();
      
      return;
      
    }

    if ( processingCommand == TRUE ) {
      //dbg(DBG_USR2, "stopped processing because already processing\n");
      
      return;
    }
    else {
      processingCommand = TRUE;
    }

    /*fill in the response message headers*/
    responseMsg->transactionID = msg->transactionID;
    responseMsg->commandID = msg->commandID;
    responseMsg->sourceAddress = TOS_NODE_ID;
    //responseMsg->sourceAddress = call AMPacket.address();
    //responseMsg->sourceAddress = TOS_LOCAL_ADDRESS;
    responseMsg->errorCode = RPC_SUCCESS;
    responseMsg->dataLength = 0;

    if( (id < 4) && (msg->dataLength != args_sizes[id]) ) {
      responseMsg->errorCode = RPC_GARBAGE_ARGS;
      //dbg(DBG_USR2, "param size doesn't match\n");
    } else if( (id < 4) && (return_sizes[id] + sizeof(RpcResponseMsg) > maxLength) ) {
      responseMsg->errorCode = RPC_RESPONSE_TOO_LARGE;
      //dbg(DBG_USR2,"Return type is too large for the response packet");
    } else switch( id ) {

      /*** BlinkC.initLeds ***/
  case 0: {
      //dbg(DBG_USR2, "handling commandId 0\n");
    call BlinkC_initLeds( );
      //dbg(DBG_USR2, "done calling the functions\n");
      //dbg(DBG_USR2, "not packing void return value\n");
  } break;

      /*** BlinkC.initLeds2 ***/
  case 1: {
    uint8_t RPC_value;
      //dbg(DBG_USR2, "handling commandId 1\n");
    memmove( &RPC_value, byteSrc, sizeof(uint8_t) );
    call BlinkC_initLeds2(  RPC_value );
      //dbg(DBG_USR2, "done calling the functions\n");
      //dbg(DBG_USR2, "not packing void return value\n");
  } break;

      /*** RamSymbolsM.peek ***/
  case 2: {
    ramSymbol_t RPC_returnVal;
    unsigned int RPC_memAddress;
    uint8_t RPC_length;
    bool RPC_dereference;
      //dbg(DBG_USR2, "handling commandId 2\n");
    memmove( &RPC_memAddress, byteSrc, sizeof(unsigned int) );
    byteSrc += sizeof(unsigned int);
    memmove( &RPC_length, byteSrc, sizeof(uint8_t) );
    byteSrc += sizeof(uint8_t);
    memmove( &RPC_dereference, byteSrc, sizeof(bool) );
    RPC_returnVal = call RamSymbolsM_peek(  RPC_memAddress, RPC_length, RPC_dereference );
    memmove( &responseMsg->data[0], &RPC_returnVal, sizeof(ramSymbol_t) );
      //dbg(DBG_USR2, "done calling the functions\n");
    responseMsg->dataLength = sizeof ( ramSymbol_t );
      //dbg(DBG_USR2, "responseMsg->dataLength = %d\n", responseMsg->dataLength);
      //dbg(DBG_USR2, " sizeof ( ramSymbol_t )= %d\n", sizeof ( ramSymbol_t ));
  } break;

      /*** RamSymbolsM.poke ***/
  case 3: {
    unsigned int RPC_returnVal;
    ramSymbol_t RPC_symbol;
      //dbg(DBG_USR2, "handling commandId 3\n");
    memmove( &RPC_symbol, byteSrc, sizeof(ramSymbol_t) );
    RPC_returnVal = call RamSymbolsM_poke(  &RPC_symbol );
    memmove( &responseMsg->data[0], &RPC_returnVal, sizeof(unsigned int) );
      //dbg(DBG_USR2, "done calling the functions\n");
    responseMsg->dataLength = sizeof ( unsigned int );
      //dbg(DBG_USR2, "responseMsg->dataLength = %d\n", responseMsg->dataLength);
      //dbg(DBG_USR2, " sizeof ( unsigned int )= %d\n", sizeof ( unsigned int ));
  } break;

    default:
        //dbg(DBG_USR2, "found no rpc function\n");
      responseMsg->errorCode = RPC_PROCEDURE_UNAVAIL;
    }
    /*** now send the response message off if necessary ***/
    //dbg(DBG_USR2, "errorCode=%d,dataLength=%d\n",responseMsg->errorCode, responseMsg->dataLength);
    //dbg(DBG_USR2, "sizeof( RpcResponseMsg ) = %d, data-transactionID= %d\n",sizeof (RpcResponseMsg),((uint32_t)&(responseMsg->data[0]) - (uint32_t)&(responseMsg->transactionID)));
 /*   if (responseMsg->errorCode == RPC_SUCCESS && responseMsg->dataLength==0){
      //dbg(DBG_USR2, "done processing, no return args\n");
      processingCommand=FALSE;
    }
    else if (responseMsg->errorCode == RPC_SUCCESS){
      //calculate the size to be the size of the data I just added 
      //plus the size of the responseMsg less the data array (the data array 
      //can sometimes take space due to compiler packing)
      if (call ResponseSendMsgDrain.send(msg->returnAddress,
				    responseMsg->dataLength + ( (uint32_t)&(responseMsg->data[0]) - (uint32_t)&(responseMsg->transactionID)),
				    responseMsgPtr) ){
        //dbg(DBG_USR2, "sending response\n");
        sendingResponse=TRUE;
      }
      else{
        //dbg(DBG_USR2, "sending response failed\n");
        processingCommand=FALSE;
      }
    }
    else{*/
      if (msg->responseDesired == 0){
        //dbg(DBG_USR2, "no response desired; not sending response message");
        processingCommand=FALSE;
      }
      else if (call AMSend.send(msg->returnAddress, responseMsgPtr, responseMsg->dataLength + sizeof(RpcResponseMsg)) ){
        //dbg(DBG_USR2, "sending response\n");
        sendingResponse=TRUE;
        
      }
      else{
        //dbg(DBG_USR2, "sending response failed\n");
        processingCommand=FALSE;
        
      }
//    }
    //dbg(DBG_USR2, "done processing.\n");
  }

  /*#ifndef RPC_NO_DRIP
  event TOS_MsgPtr CommandReceiveDrip.receive(TOS_MsgPtr pMsg, void* payload, uint16_t payloadLength) {
    RpcCommandMsg* msg = (RpcCommandMsg*)payload;

    //dbg(DBG_USR2, "received drip command message\n");

    //store the drip message for later drip rebroadcasting
    memmove(dripStore.data, payload, payloadLength);
    dripStoreLength = payloadLength;

    //if it is destined to us, post a task to process it
    if (msg->address == TOS_LOCAL_ADDRESS || msg->address == TOS_BCAST_ADDR ) {
      //store another copy for later processing
      memmove(cmdStore.data, payload, payloadLength);
      cmdStoreLength = payloadLength;

      if (post processCommand() == SUCCESS){
        //dbg(DBG_USR2, "posted task\n");
      } 
      else{
        //dbg(DBG_USR2, "failed to post task\n");
      }
    }
    else {
      //dbg(DBG_USR2, "not posting task because not for me\n");
    }

    return pMsg;
  }
#endif // !RPC_NO_DRIP
  */
  event message_t* Receive.receive(message_t* pMsg, void* payload, uint8_t len) {
    //dbg(DBG_USR2, "received local command message, len=0\n",pMsg->length);

    //if it is destined to us, post a task to process it
    RpcCommandMsg* msg = (RpcCommandMsg*)payload;
    if (msg->address == TOS_NODE_ID || msg->address == AM_BROADCAST_ADDR ) {
      //store the message for later processing
      memmove(cmdStore.data, payload, len);
      cmdStoreLength = len;
      if (post processCommand() == SUCCESS){
	//dbg(DBG_USR2, "posted task\n");
      } 
      else{
	//dbg(DBG_USR2, "failed to post task\n");
      }
    }
    else {
      //dbg(DBG_USR2, "not posting task because not for me\n");
    }
    return pMsg;
  }


  /*#ifndef RPC_NO_DRIP
  event error_t CommandDrip.rebroadcastRequest(TOS_MsgPtr msg, void *payload) {
    //dbg(DBG_USR2, "drip rebroadcast request\n");
    memmove(payload, dripStore.data, dripStoreLength);
    call CommandDrip.rebroadcast(msg, payload, dripStoreLength);    
    return SUCCESS;
  }
#endif // !RPC_NO_DRIP

#ifndef RPC_NO_DRAIN
  event error_t DrainSend.sendDone(TOS_MsgPtr pMsg, result_t success) {
    dbg(DBG_USR2, "wtf!!  drainSend send done\n");
    return SUCCESS;
  }
#endif // !RPC_NO_DRAIN
  event error_t ResponseSendMsg.sendDone(TOS_MsgPtr pMsg, result_t success) {
    if (success == SUCCESS) {
      dbg(DBG_USR2, "drain send done: SUCCESS\n");
    }
    else{
      dbg(DBG_USR2, "drain send done: FAIL\n");
    }
    processingCommand = FALSE;
    sendingResponse = FALSE;
    return SUCCESS;
  }
  event result_t ErrorSendMsgDrain.sendDone(TOS_MsgPtr pMsg, result_t success) {
    if (success == SUCCESS) {
      dbg(DBG_USR2, "drain error send done: SUCCESS\n");
    }
    else{
      dbg(DBG_USR2, "drain error send done: FAIL\n");
    }
    processingCommand = FALSE;
    sendingResponse = FALSE;
    return SUCCESS;
  }*/
  event void AMSend.sendDone(message_t* pMsg, error_t success) {
    processingCommand = FALSE;
    sendingResponse = FALSE;
  }


}
